module Main where

import B21.Api
import B21.Types

import Calendar
import Timesheet ( makeTimesheet )

import Control.Concurrent.Async ( async, waitCatch )
import Control.Concurrent.MVar
import Control.Exception ( SomeException )
import Control.Monad ( forM_, when )
import Control.Monad.IO.Class
import Data.Text ( Text )
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.IO as T
import Network.Wai.Handler.Warp
import Network.Wai.Middleware.RequestLogger ( logStdoutDev )
import Network.HTTP.Client ( parseRequest_, Request, Manager, newManager )
import Network.HTTP.Client.TLS ( tlsManagerSettings )
import Servant
import System.Directory
import System.Environment ( getEnv, getEnvironment )
import System.FilePath
import System.IO ( FilePath )
import System.Random ( getStdRandom, randomR )

type Lock = MVar ()

data SiteConfig =
  SiteConfig
    { confEmailFilePath :: FilePath
    , confServerPort :: Int
    , confFileLock :: Lock
    , confCalendarReq :: Request
    , confHttpManager :: Manager
    , confTimesheetScript :: FilePath
    -- ^ the path to the timesheet script
    , confPdfOutDir :: FilePath
    -- ^ directory in which pdfs are generated by the timesheet script
    , confEnv :: [(String, String)]
    -- ^ the complete environment upon startup
    , confStaticDir :: FilePath
    -- ^ directory that serves static files
    , confStaticUrlPrefix :: FilePath
    -- ^ prefix for static urls with pdfs in them, e.g.
    -- @https://building21.ca/pdf@
    }

-- | Await a lock, perform an action, and restore the lock.
-- This operation is exception-safe; if the action raises an exception, the
-- lock is released.
locking :: Lock -> IO a -> IO a
locking l m = withMVar l (const m)

getConfig :: IO SiteConfig
getConfig = do
  port <- read <$> getEnv "B21_API_PORT"
  path <- getEnv "B21_EMAIL_FILEPATH"
  calReq <- parseRequest_ <$> getEnv "B21_CALENDAR_URI"
  lock <- newMVar ()
  man <- newManager tlsManagerSettings
  ts <- getEnv "B21_TIMESHEET_SCRIPT"
  pdfDir <- getEnv "B21_PDF_DIR"
  staticDir <- getEnv "B21_STATIC_DIR"
  staticUrl <- getEnv "B21_STATIC_URL_PREFIX"
  e <- getEnvironment
  pure SiteConfig
    { confEmailFilePath = path
    , confServerPort = port
    , confFileLock = lock
    , confCalendarReq = calReq
    , confHttpManager = man
    , confTimesheetScript = ts
    , confPdfOutDir = pdfDir
    , confEnv = e
    , confStaticDir = staticDir
    , confStaticUrlPrefix = staticUrl
    }

main :: IO ()
main = do
  conf <- getConfig
  run (confServerPort conf) $ logStdoutDev $ serve b21Api $ server conf

catchAll :: IO a -> IO (Either SomeException a)
catchAll m = async m >>= waitCatch

server :: SiteConfig -> Server B21Api
server SiteConfig{..} = addEmail :<|> getEvents :<|> timesheet where
  addEmail :: AddEmail -> Handler Text
  addEmail AddEmail{..} = do
    liftIO (catchAll $ addEmail' addEmailAddress) >>= \case
      Left _ -> throwError err500 { errBody = "something happened" }
      Right _ -> pure "ok"

  getEvents :: Handler [Event]
  getEvents = liftIO $ do
    let r (ers, evs) (ers', evs') = (ers ++ ers', evs ++ evs')
    (ers, evs) <- foldr r ([], []) . fmap events . fst
      <$> getRemoteCalendar confCalendarReq confHttpManager

    forM_ ers $ \e -> putStrLn $ "error interpreting event: " ++ e

    pure evs

  timesheet
    :: CreateTimesheet -- ^ timesheet creation parameters
    -> Handler ()
  timesheet cts = do
    -- filename to store the pdf in is randomly chosen
    i <- show <$> liftIO (getStdRandom (randomR (0 :: Int, maxBound)))
    let name = i <.> "pdf"
    b <- liftIO $
      makeTimesheet (confPdfOutDir </> name) confTimesheetScript (Just confEnv) cts
    -- get out the path to the pdf
    when (not b) $ do
      throwError err500 { errBody = "failed to create timesheet" }

    liftIO $ copyFile (confPdfOutDir </> name) (confStaticDir </> name)

    redirect $ T.encodeUtf8 $ T.pack (confStaticUrlPrefix </> name)

  addEmail' :: Text -> IO ()
  addEmail' x = locking confFileLock (T.appendFile confEmailFilePath x)

redirect to = throwError err301 { errHeaders = hds } where
  hds = [("Location", to)]
