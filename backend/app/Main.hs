module Main where

import B21.Api
import B21.Timesheet ( makeTimesheet )
import B21.Types

import Calendar

import Control.Concurrent.Async ( async, waitCatch )
import Control.Concurrent.MVar
import Control.Exception ( SomeException )
import Control.Monad ( forM_, when )
import Control.Monad.IO.Class
import Data.Text ( Text )
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Text.IO as T
import Network.Wai.Handler.Warp
import Network.Wai.Middleware.RequestLogger ( logStdoutDev )
import Network.HTTP.Client ( parseRequest_, Request, Manager, newManager )
import Network.HTTP.Client.TLS ( tlsManagerSettings )
import Servant
import System.Directory
import System.Environment ( getEnv, getEnvironment )
import System.FilePath
import System.IO ( FilePath )
import System.Random ( getStdRandom, randomR )

type Lock = MVar ()

data SiteConfig =
  SiteConfig
    { confServerPort :: Int
    , confHttpManager :: Manager
    , confTimesheetBase :: FilePath
    -- ^ the path to the base timesheet
    , confTimesheetScript :: FilePath
    -- ^ the path to the timesheet script
    , confPdfOutDir :: FilePath
    -- ^ directory in which pdfs are generated by the timesheet script
    , confEnv :: [(String, String)]
    -- ^ the complete environment upon startup
    , confStaticDir :: FilePath
    -- ^ directory that serves static files
    , confStaticUrlPrefix :: FilePath
    -- ^ prefix for static urls with pdfs in them, e.g.
    -- @https://building21.ca/pdf@
    }

-- | Await a lock, perform an action, and restore the lock.
-- This operation is exception-safe; if the action raises an exception, the
-- lock is released.
locking :: Lock -> IO a -> IO a
locking l m = withMVar l (const m)

getConfig :: IO SiteConfig
getConfig = do
  lock <- newMVar ()
  man <- newManager tlsManagerSettings
  port <- read <$> getEnv "B21_API_PORT"
  ts <- getEnv "B21_TIMESHEET_SCRIPT"
  pdfDir <- getEnv "B21_PDF_DIR"
  staticDir <- getEnv "B21_STATIC_DIR"
  staticUrl <- getEnv "B21_STATIC_URL_PREFIX"
  tsbase <- getEnv "B21_TIMESHEET_BASE"

  e <- getEnvironment
  pure SiteConfig
    { confServerPort = port
    , confHttpManager = man
    , confTimesheetScript = ts
    , confPdfOutDir = pdfDir
    , confEnv = e
    , confStaticDir = staticDir
    , confStaticUrlPrefix = staticUrl
    , confTimesheetBase = tsbase
    }

main :: IO ()
main = do
  conf <- getConfig
  run (confServerPort conf) $ logStdoutDev $ serve b21Api $ server conf

catchAll :: IO a -> IO (Either SomeException a)
catchAll m = async m >>= waitCatch

server :: SiteConfig -> Server B21Api
server SiteConfig{..} = timesheet where
  timesheet
    :: CreateTimesheet -- ^ timesheet creation parameters
    -> Handler ()
  timesheet cts = do
    -- filename to store the pdf in is randomly chosen
    liftIO $ putStrLn "making timesheet"
    i <- show <$> liftIO (getStdRandom (randomR (0 :: Int, maxBound)))
    let name = i <.> "pdf"
    b <- liftIO $ makeTimesheet
      (confPdfOutDir </> name)
      confTimesheetScript
      confTimesheetBase
      (Just confEnv)
      cts
    -- get out the path to the pdf
    when (not b) $ do
      throwError err500 { errBody = "failed to create timesheet" }

    liftIO $ copyFile (confPdfOutDir </> name) (confStaticDir </> name)

    redirect $ T.encodeUtf8 $ T.pack (confStaticUrlPrefix </> name)

redirect to = throwError err301 { errHeaders = hds } where
  hds = [("Location", to)]
